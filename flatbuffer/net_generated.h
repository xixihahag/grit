// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NET_FLAT_H_
#define FLATBUFFERS_GENERATED_NET_FLAT_H_

#include "flatbuffers/flatbuffers.h"

namespace flat {

struct Gtm;
struct GtmBuilder;

struct ipAndPort;
struct ipAndPortBuilder;

struct GtmAck;
struct GtmAckBuilder;

struct WriteData;
struct WriteDataBuilder;

struct ReadData;
struct ReadDataBuilder;

struct DbService;
struct DbServiceBuilder;

struct LogStore;
struct LogStoreBuilder;

struct LogStoreAck;
struct LogStoreAckBuilder;

struct RootMsg;
struct RootMsgBuilder;

enum Msg {
  Msg_NONE = 0,
  Msg_Gtm = 1,
  Msg_GtmAck = 2,
  Msg_DbService = 3,
  Msg_LogStore = 4,
  Msg_LogStoreAck = 5,
  Msg_MIN = Msg_NONE,
  Msg_MAX = Msg_LogStoreAck
};

inline const Msg (&EnumValuesMsg())[6] {
  static const Msg values[] = {
    Msg_NONE,
    Msg_Gtm,
    Msg_GtmAck,
    Msg_DbService,
    Msg_LogStore,
    Msg_LogStoreAck
  };
  return values;
}

inline const char * const *EnumNamesMsg() {
  static const char * const names[7] = {
    "NONE",
    "Gtm",
    "GtmAck",
    "DbService",
    "LogStore",
    "LogStoreAck",
    nullptr
  };
  return names;
}

inline const char *EnumNameMsg(Msg e) {
  if (flatbuffers::IsOutRange(e, Msg_NONE, Msg_LogStoreAck)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMsg()[index];
}

template<typename T> struct MsgTraits {
  static const Msg enum_value = Msg_NONE;
};

template<> struct MsgTraits<flat::Gtm> {
  static const Msg enum_value = Msg_Gtm;
};

template<> struct MsgTraits<flat::GtmAck> {
  static const Msg enum_value = Msg_GtmAck;
};

template<> struct MsgTraits<flat::DbService> {
  static const Msg enum_value = Msg_DbService;
};

template<> struct MsgTraits<flat::LogStore> {
  static const Msg enum_value = Msg_LogStore;
};

template<> struct MsgTraits<flat::LogStoreAck> {
  static const Msg enum_value = Msg_LogStoreAck;
};

bool VerifyMsg(flatbuffers::Verifier &verifier, const void *obj, Msg type);
bool VerifyMsgVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Gtm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GtmBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_TRANSTYPE = 6
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::String *transType() const {
    return GetPointer<const flatbuffers::String *>(VT_TRANSTYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_TRANSTYPE) &&
           verifier.VerifyString(transType()) &&
           verifier.EndTable();
  }
};

struct GtmBuilder {
  typedef Gtm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Gtm::VT_TYPE, type, 0);
  }
  void add_transType(flatbuffers::Offset<flatbuffers::String> transType) {
    fbb_.AddOffset(Gtm::VT_TRANSTYPE, transType);
  }
  explicit GtmBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GtmBuilder &operator=(const GtmBuilder &);
  flatbuffers::Offset<Gtm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gtm>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gtm> CreateGtm(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    flatbuffers::Offset<flatbuffers::String> transType = 0) {
  GtmBuilder builder_(_fbb);
  builder_.add_transType(transType);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Gtm> CreateGtmDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    const char *transType = nullptr) {
  auto transType__ = transType ? _fbb.CreateString(transType) : 0;
  return flat::CreateGtm(
      _fbb,
      type,
      transType__);
}

struct ipAndPort FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ipAndPortBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IP = 4,
    VT_PORT = 6
  };
  const flatbuffers::String *ip() const {
    return GetPointer<const flatbuffers::String *>(VT_IP);
  }
  int32_t port() const {
    return GetField<int32_t>(VT_PORT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IP) &&
           verifier.VerifyString(ip()) &&
           VerifyField<int32_t>(verifier, VT_PORT) &&
           verifier.EndTable();
  }
};

struct ipAndPortBuilder {
  typedef ipAndPort Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ip(flatbuffers::Offset<flatbuffers::String> ip) {
    fbb_.AddOffset(ipAndPort::VT_IP, ip);
  }
  void add_port(int32_t port) {
    fbb_.AddElement<int32_t>(ipAndPort::VT_PORT, port, 0);
  }
  explicit ipAndPortBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ipAndPortBuilder &operator=(const ipAndPortBuilder &);
  flatbuffers::Offset<ipAndPort> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ipAndPort>(end);
    return o;
  }
};

inline flatbuffers::Offset<ipAndPort> CreateipAndPort(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ip = 0,
    int32_t port = 0) {
  ipAndPortBuilder builder_(_fbb);
  builder_.add_port(port);
  builder_.add_ip(ip);
  return builder_.Finish();
}

inline flatbuffers::Offset<ipAndPort> CreateipAndPortDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ip = nullptr,
    int32_t port = 0) {
  auto ip__ = ip ? _fbb.CreateString(ip) : 0;
  return flat::CreateipAndPort(
      _fbb,
      ip__,
      port);
}

struct GtmAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GtmAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TXID = 4,
    VT_LIST = 6
  };
  int32_t txid() const {
    return GetField<int32_t>(VT_TXID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::ipAndPort>> *list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::ipAndPort>> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TXID) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.VerifyVector(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           verifier.EndTable();
  }
};

struct GtmAckBuilder {
  typedef GtmAck Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_txid(int32_t txid) {
    fbb_.AddElement<int32_t>(GtmAck::VT_TXID, txid, 0);
  }
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ipAndPort>>> list) {
    fbb_.AddOffset(GtmAck::VT_LIST, list);
  }
  explicit GtmAckBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GtmAckBuilder &operator=(const GtmAckBuilder &);
  flatbuffers::Offset<GtmAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GtmAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<GtmAck> CreateGtmAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t txid = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ipAndPort>>> list = 0) {
  GtmAckBuilder builder_(_fbb);
  builder_.add_list(list);
  builder_.add_txid(txid);
  return builder_.Finish();
}

inline flatbuffers::Offset<GtmAck> CreateGtmAckDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t txid = 0,
    const std::vector<flatbuffers::Offset<flat::ipAndPort>> *list = nullptr) {
  auto list__ = list ? _fbb.CreateVector<flatbuffers::Offset<flat::ipAndPort>>(*list) : 0;
  return flat::CreateGtmAck(
      _fbb,
      txid,
      list__);
}

struct WriteData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WriteDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_RECORD = 6,
    VT_VALUE = 8
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::String *record() const {
    return GetPointer<const flatbuffers::String *>(VT_RECORD);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_RECORD) &&
           verifier.VerifyString(record()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct WriteDataBuilder {
  typedef WriteData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(WriteData::VT_KEY, key);
  }
  void add_record(flatbuffers::Offset<flatbuffers::String> record) {
    fbb_.AddOffset(WriteData::VT_RECORD, record);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(WriteData::VT_VALUE, value);
  }
  explicit WriteDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WriteDataBuilder &operator=(const WriteDataBuilder &);
  flatbuffers::Offset<WriteData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WriteData>(end);
    return o;
  }
};

inline flatbuffers::Offset<WriteData> CreateWriteData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> record = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  WriteDataBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_record(record);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<WriteData> CreateWriteDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *record = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto record__ = record ? _fbb.CreateString(record) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return flat::CreateWriteData(
      _fbb,
      key__,
      record__,
      value__);
}

struct ReadData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReadDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           verifier.EndTable();
  }
};

struct ReadDataBuilder {
  typedef ReadData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(ReadData::VT_KEY, key);
  }
  explicit ReadDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadDataBuilder &operator=(const ReadDataBuilder &);
  flatbuffers::Offset<ReadData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReadData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReadData> CreateReadData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0) {
  ReadDataBuilder builder_(_fbb);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReadData> CreateReadDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return flat::CreateReadData(
      _fbb,
      key__);
}

struct DbService FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DbServiceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_TXID = 6,
    VT_ISCONFLICT = 8,
    VT_LSN = 10,
    VT_READSET = 12,
    VT_WRITESET = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t txid() const {
    return GetField<int32_t>(VT_TXID, 0);
  }
  bool isConflict() const {
    return GetField<uint8_t>(VT_ISCONFLICT, 0) != 0;
  }
  int32_t lsn() const {
    return GetField<int32_t>(VT_LSN, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::ReadData>> *readSet() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::ReadData>> *>(VT_READSET);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::WriteData>> *writeSet() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::WriteData>> *>(VT_WRITESET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_TXID) &&
           VerifyField<uint8_t>(verifier, VT_ISCONFLICT) &&
           VerifyField<int32_t>(verifier, VT_LSN) &&
           VerifyOffset(verifier, VT_READSET) &&
           verifier.VerifyVector(readSet()) &&
           verifier.VerifyVectorOfTables(readSet()) &&
           VerifyOffset(verifier, VT_WRITESET) &&
           verifier.VerifyVector(writeSet()) &&
           verifier.VerifyVectorOfTables(writeSet()) &&
           verifier.EndTable();
  }
};

struct DbServiceBuilder {
  typedef DbService Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(DbService::VT_TYPE, type, 0);
  }
  void add_txid(int32_t txid) {
    fbb_.AddElement<int32_t>(DbService::VT_TXID, txid, 0);
  }
  void add_isConflict(bool isConflict) {
    fbb_.AddElement<uint8_t>(DbService::VT_ISCONFLICT, static_cast<uint8_t>(isConflict), 0);
  }
  void add_lsn(int32_t lsn) {
    fbb_.AddElement<int32_t>(DbService::VT_LSN, lsn, 0);
  }
  void add_readSet(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ReadData>>> readSet) {
    fbb_.AddOffset(DbService::VT_READSET, readSet);
  }
  void add_writeSet(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::WriteData>>> writeSet) {
    fbb_.AddOffset(DbService::VT_WRITESET, writeSet);
  }
  explicit DbServiceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DbServiceBuilder &operator=(const DbServiceBuilder &);
  flatbuffers::Offset<DbService> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DbService>(end);
    return o;
  }
};

inline flatbuffers::Offset<DbService> CreateDbService(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    int32_t txid = 0,
    bool isConflict = false,
    int32_t lsn = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ReadData>>> readSet = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::WriteData>>> writeSet = 0) {
  DbServiceBuilder builder_(_fbb);
  builder_.add_writeSet(writeSet);
  builder_.add_readSet(readSet);
  builder_.add_lsn(lsn);
  builder_.add_txid(txid);
  builder_.add_type(type);
  builder_.add_isConflict(isConflict);
  return builder_.Finish();
}

inline flatbuffers::Offset<DbService> CreateDbServiceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    int32_t txid = 0,
    bool isConflict = false,
    int32_t lsn = 0,
    const std::vector<flatbuffers::Offset<flat::ReadData>> *readSet = nullptr,
    const std::vector<flatbuffers::Offset<flat::WriteData>> *writeSet = nullptr) {
  auto readSet__ = readSet ? _fbb.CreateVector<flatbuffers::Offset<flat::ReadData>>(*readSet) : 0;
  auto writeSet__ = writeSet ? _fbb.CreateVector<flatbuffers::Offset<flat::WriteData>>(*writeSet) : 0;
  return flat::CreateDbService(
      _fbb,
      type,
      txid,
      isConflict,
      lsn,
      readSet__,
      writeSet__);
}

struct LogStore FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogStoreBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_TXID = 6
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t txid() const {
    return GetField<int32_t>(VT_TXID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_TXID) &&
           verifier.EndTable();
  }
};

struct LogStoreBuilder {
  typedef LogStore Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(LogStore::VT_TYPE, type, 0);
  }
  void add_txid(int32_t txid) {
    fbb_.AddElement<int32_t>(LogStore::VT_TXID, txid, 0);
  }
  explicit LogStoreBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogStoreBuilder &operator=(const LogStoreBuilder &);
  flatbuffers::Offset<LogStore> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogStore>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogStore> CreateLogStore(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    int32_t txid = 0) {
  LogStoreBuilder builder_(_fbb);
  builder_.add_txid(txid);
  builder_.add_type(type);
  return builder_.Finish();
}

struct LogStoreAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogStoreAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LSN = 4,
    VT_TXID = 6
  };
  int32_t lsn() const {
    return GetField<int32_t>(VT_LSN, 0);
  }
  int32_t txid() const {
    return GetField<int32_t>(VT_TXID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LSN) &&
           VerifyField<int32_t>(verifier, VT_TXID) &&
           verifier.EndTable();
  }
};

struct LogStoreAckBuilder {
  typedef LogStoreAck Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lsn(int32_t lsn) {
    fbb_.AddElement<int32_t>(LogStoreAck::VT_LSN, lsn, 0);
  }
  void add_txid(int32_t txid) {
    fbb_.AddElement<int32_t>(LogStoreAck::VT_TXID, txid, 0);
  }
  explicit LogStoreAckBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogStoreAckBuilder &operator=(const LogStoreAckBuilder &);
  flatbuffers::Offset<LogStoreAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogStoreAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogStoreAck> CreateLogStoreAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t lsn = 0,
    int32_t txid = 0) {
  LogStoreAckBuilder builder_(_fbb);
  builder_.add_txid(txid);
  builder_.add_lsn(lsn);
  return builder_.Finish();
}

struct RootMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RootMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANY_TYPE = 4,
    VT_ANY = 6
  };
  flat::Msg any_type() const {
    return static_cast<flat::Msg>(GetField<uint8_t>(VT_ANY_TYPE, 0));
  }
  const void *any() const {
    return GetPointer<const void *>(VT_ANY);
  }
  template<typename T> const T *any_as() const;
  const flat::Gtm *any_as_Gtm() const {
    return any_type() == flat::Msg_Gtm ? static_cast<const flat::Gtm *>(any()) : nullptr;
  }
  const flat::GtmAck *any_as_GtmAck() const {
    return any_type() == flat::Msg_GtmAck ? static_cast<const flat::GtmAck *>(any()) : nullptr;
  }
  const flat::DbService *any_as_DbService() const {
    return any_type() == flat::Msg_DbService ? static_cast<const flat::DbService *>(any()) : nullptr;
  }
  const flat::LogStore *any_as_LogStore() const {
    return any_type() == flat::Msg_LogStore ? static_cast<const flat::LogStore *>(any()) : nullptr;
  }
  const flat::LogStoreAck *any_as_LogStoreAck() const {
    return any_type() == flat::Msg_LogStoreAck ? static_cast<const flat::LogStoreAck *>(any()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ANY_TYPE) &&
           VerifyOffset(verifier, VT_ANY) &&
           VerifyMsg(verifier, any(), any_type()) &&
           verifier.EndTable();
  }
};

template<> inline const flat::Gtm *RootMsg::any_as<flat::Gtm>() const {
  return any_as_Gtm();
}

template<> inline const flat::GtmAck *RootMsg::any_as<flat::GtmAck>() const {
  return any_as_GtmAck();
}

template<> inline const flat::DbService *RootMsg::any_as<flat::DbService>() const {
  return any_as_DbService();
}

template<> inline const flat::LogStore *RootMsg::any_as<flat::LogStore>() const {
  return any_as_LogStore();
}

template<> inline const flat::LogStoreAck *RootMsg::any_as<flat::LogStoreAck>() const {
  return any_as_LogStoreAck();
}

struct RootMsgBuilder {
  typedef RootMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_any_type(flat::Msg any_type) {
    fbb_.AddElement<uint8_t>(RootMsg::VT_ANY_TYPE, static_cast<uint8_t>(any_type), 0);
  }
  void add_any(flatbuffers::Offset<void> any) {
    fbb_.AddOffset(RootMsg::VT_ANY, any);
  }
  explicit RootMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RootMsgBuilder &operator=(const RootMsgBuilder &);
  flatbuffers::Offset<RootMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RootMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<RootMsg> CreateRootMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flat::Msg any_type = flat::Msg_NONE,
    flatbuffers::Offset<void> any = 0) {
  RootMsgBuilder builder_(_fbb);
  builder_.add_any(any);
  builder_.add_any_type(any_type);
  return builder_.Finish();
}

inline bool VerifyMsg(flatbuffers::Verifier &verifier, const void *obj, Msg type) {
  switch (type) {
    case Msg_NONE: {
      return true;
    }
    case Msg_Gtm: {
      auto ptr = reinterpret_cast<const flat::Gtm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Msg_GtmAck: {
      auto ptr = reinterpret_cast<const flat::GtmAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Msg_DbService: {
      auto ptr = reinterpret_cast<const flat::DbService *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Msg_LogStore: {
      auto ptr = reinterpret_cast<const flat::LogStore *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Msg_LogStoreAck: {
      auto ptr = reinterpret_cast<const flat::LogStoreAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMsgVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMsg(
        verifier,  values->Get(i), types->GetEnum<Msg>(i))) {
      return false;
    }
  }
  return true;
}

inline const flat::RootMsg *GetRootMsg(const void *buf) {
  return flatbuffers::GetRoot<flat::RootMsg>(buf);
}

inline const flat::RootMsg *GetSizePrefixedRootMsg(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<flat::RootMsg>(buf);
}

inline bool VerifyRootMsgBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flat::RootMsg>(nullptr);
}

inline bool VerifySizePrefixedRootMsgBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<flat::RootMsg>(nullptr);
}

inline void FinishRootMsgBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::RootMsg> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRootMsgBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::RootMsg> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flat

#endif  // FLATBUFFERS_GENERATED_NET_FLAT_H_
