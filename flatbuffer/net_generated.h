// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NET_FLAT_H_
#define FLATBUFFERS_GENERATED_NET_FLAT_H_

#include "flatbuffers/flatbuffers.h"

namespace flat {

struct GtmMsg;
struct GtmMsgBuilder;

struct ipAndPort;
struct ipAndPortBuilder;

struct AppMsg;
struct AppMsgBuilder;

struct ESMsg;
struct ESMsgBuilder;

struct Data;
struct DataBuilder;

struct DbServiceMsg;
struct DbServiceMsgBuilder;

struct DbtlMsg;
struct DbtlMsgBuilder;

struct DbtlAckMsg;
struct DbtlAckMsgBuilder;

struct RootMsg;
struct RootMsgBuilder;

enum Msg {
  Msg_NONE = 0,
  Msg_GtmMsg = 1,
  Msg_AppMsg = 2,
  Msg_DbServiceMsg = 3,
  Msg_DbtlMsg = 4,
  Msg_DbtlAckMsg = 5,
  Msg_ESMsg = 6,
  Msg_MIN = Msg_NONE,
  Msg_MAX = Msg_ESMsg
};

inline const Msg (&EnumValuesMsg())[7] {
  static const Msg values[] = {
    Msg_NONE,
    Msg_GtmMsg,
    Msg_AppMsg,
    Msg_DbServiceMsg,
    Msg_DbtlMsg,
    Msg_DbtlAckMsg,
    Msg_ESMsg
  };
  return values;
}

inline const char * const *EnumNamesMsg() {
  static const char * const names[8] = {
    "NONE",
    "GtmMsg",
    "AppMsg",
    "DbServiceMsg",
    "DbtlMsg",
    "DbtlAckMsg",
    "ESMsg",
    nullptr
  };
  return names;
}

inline const char *EnumNameMsg(Msg e) {
  if (flatbuffers::IsOutRange(e, Msg_NONE, Msg_ESMsg)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMsg()[index];
}

template<typename T> struct MsgTraits {
  static const Msg enum_value = Msg_NONE;
};

template<> struct MsgTraits<flat::GtmMsg> {
  static const Msg enum_value = Msg_GtmMsg;
};

template<> struct MsgTraits<flat::AppMsg> {
  static const Msg enum_value = Msg_AppMsg;
};

template<> struct MsgTraits<flat::DbServiceMsg> {
  static const Msg enum_value = Msg_DbServiceMsg;
};

template<> struct MsgTraits<flat::DbtlMsg> {
  static const Msg enum_value = Msg_DbtlMsg;
};

template<> struct MsgTraits<flat::DbtlAckMsg> {
  static const Msg enum_value = Msg_DbtlAckMsg;
};

template<> struct MsgTraits<flat::ESMsg> {
  static const Msg enum_value = Msg_ESMsg;
};

bool VerifyMsg(flatbuffers::Verifier &verifier, const void *obj, Msg type);
bool VerifyMsgVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct GtmMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GtmMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD = 4,
    VT_TRANSTYPE = 6
  };
  int32_t cmd() const {
    return GetField<int32_t>(VT_CMD, 0);
  }
  const flatbuffers::String *transType() const {
    return GetPointer<const flatbuffers::String *>(VT_TRANSTYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CMD) &&
           VerifyOffset(verifier, VT_TRANSTYPE) &&
           verifier.VerifyString(transType()) &&
           verifier.EndTable();
  }
};

struct GtmMsgBuilder {
  typedef GtmMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cmd(int32_t cmd) {
    fbb_.AddElement<int32_t>(GtmMsg::VT_CMD, cmd, 0);
  }
  void add_transType(flatbuffers::Offset<flatbuffers::String> transType) {
    fbb_.AddOffset(GtmMsg::VT_TRANSTYPE, transType);
  }
  explicit GtmMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GtmMsgBuilder &operator=(const GtmMsgBuilder &);
  flatbuffers::Offset<GtmMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GtmMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<GtmMsg> CreateGtmMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cmd = 0,
    flatbuffers::Offset<flatbuffers::String> transType = 0) {
  GtmMsgBuilder builder_(_fbb);
  builder_.add_transType(transType);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

inline flatbuffers::Offset<GtmMsg> CreateGtmMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cmd = 0,
    const char *transType = nullptr) {
  auto transType__ = transType ? _fbb.CreateString(transType) : 0;
  return flat::CreateGtmMsg(
      _fbb,
      cmd,
      transType__);
}

struct ipAndPort FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ipAndPortBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IP = 4,
    VT_PORT = 6
  };
  const flatbuffers::String *ip() const {
    return GetPointer<const flatbuffers::String *>(VT_IP);
  }
  int32_t port() const {
    return GetField<int32_t>(VT_PORT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IP) &&
           verifier.VerifyString(ip()) &&
           VerifyField<int32_t>(verifier, VT_PORT) &&
           verifier.EndTable();
  }
};

struct ipAndPortBuilder {
  typedef ipAndPort Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ip(flatbuffers::Offset<flatbuffers::String> ip) {
    fbb_.AddOffset(ipAndPort::VT_IP, ip);
  }
  void add_port(int32_t port) {
    fbb_.AddElement<int32_t>(ipAndPort::VT_PORT, port, 0);
  }
  explicit ipAndPortBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ipAndPortBuilder &operator=(const ipAndPortBuilder &);
  flatbuffers::Offset<ipAndPort> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ipAndPort>(end);
    return o;
  }
};

inline flatbuffers::Offset<ipAndPort> CreateipAndPort(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ip = 0,
    int32_t port = 0) {
  ipAndPortBuilder builder_(_fbb);
  builder_.add_port(port);
  builder_.add_ip(ip);
  return builder_.Finish();
}

inline flatbuffers::Offset<ipAndPort> CreateipAndPortDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ip = nullptr,
    int32_t port = 0) {
  auto ip__ = ip ? _fbb.CreateString(ip) : 0;
  return flat::CreateipAndPort(
      _fbb,
      ip__,
      port);
}

struct AppMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AppMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD = 4,
    VT_TXID = 6,
    VT_LIST = 8
  };
  int32_t cmd() const {
    return GetField<int32_t>(VT_CMD, 0);
  }
  int32_t txid() const {
    return GetField<int32_t>(VT_TXID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::ipAndPort>> *list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::ipAndPort>> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CMD) &&
           VerifyField<int32_t>(verifier, VT_TXID) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.VerifyVector(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           verifier.EndTable();
  }
};

struct AppMsgBuilder {
  typedef AppMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cmd(int32_t cmd) {
    fbb_.AddElement<int32_t>(AppMsg::VT_CMD, cmd, 0);
  }
  void add_txid(int32_t txid) {
    fbb_.AddElement<int32_t>(AppMsg::VT_TXID, txid, 0);
  }
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ipAndPort>>> list) {
    fbb_.AddOffset(AppMsg::VT_LIST, list);
  }
  explicit AppMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AppMsgBuilder &operator=(const AppMsgBuilder &);
  flatbuffers::Offset<AppMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AppMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<AppMsg> CreateAppMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cmd = 0,
    int32_t txid = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ipAndPort>>> list = 0) {
  AppMsgBuilder builder_(_fbb);
  builder_.add_list(list);
  builder_.add_txid(txid);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

inline flatbuffers::Offset<AppMsg> CreateAppMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cmd = 0,
    int32_t txid = 0,
    const std::vector<flatbuffers::Offset<flat::ipAndPort>> *list = nullptr) {
  auto list__ = list ? _fbb.CreateVector<flatbuffers::Offset<flat::ipAndPort>>(*list) : 0;
  return flat::CreateAppMsg(
      _fbb,
      cmd,
      txid,
      list__);
}

struct ESMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ESMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD = 4,
    VT_TXID = 6,
    VT_TYPE = 8,
    VT_ATTR = 10,
    VT_VAL = 12
  };
  int32_t cmd() const {
    return GetField<int32_t>(VT_CMD, 0);
  }
  int32_t txid() const {
    return GetField<int32_t>(VT_TXID, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::String *attr() const {
    return GetPointer<const flatbuffers::String *>(VT_ATTR);
  }
  const flatbuffers::String *val() const {
    return GetPointer<const flatbuffers::String *>(VT_VAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CMD) &&
           VerifyField<int32_t>(verifier, VT_TXID) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ATTR) &&
           verifier.VerifyString(attr()) &&
           VerifyOffset(verifier, VT_VAL) &&
           verifier.VerifyString(val()) &&
           verifier.EndTable();
  }
};

struct ESMsgBuilder {
  typedef ESMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cmd(int32_t cmd) {
    fbb_.AddElement<int32_t>(ESMsg::VT_CMD, cmd, 0);
  }
  void add_txid(int32_t txid) {
    fbb_.AddElement<int32_t>(ESMsg::VT_TXID, txid, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ESMsg::VT_TYPE, type, 0);
  }
  void add_attr(flatbuffers::Offset<flatbuffers::String> attr) {
    fbb_.AddOffset(ESMsg::VT_ATTR, attr);
  }
  void add_val(flatbuffers::Offset<flatbuffers::String> val) {
    fbb_.AddOffset(ESMsg::VT_VAL, val);
  }
  explicit ESMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ESMsgBuilder &operator=(const ESMsgBuilder &);
  flatbuffers::Offset<ESMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ESMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<ESMsg> CreateESMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cmd = 0,
    int32_t txid = 0,
    int32_t type = 0,
    flatbuffers::Offset<flatbuffers::String> attr = 0,
    flatbuffers::Offset<flatbuffers::String> val = 0) {
  ESMsgBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_attr(attr);
  builder_.add_type(type);
  builder_.add_txid(txid);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

inline flatbuffers::Offset<ESMsg> CreateESMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cmd = 0,
    int32_t txid = 0,
    int32_t type = 0,
    const char *attr = nullptr,
    const char *val = nullptr) {
  auto attr__ = attr ? _fbb.CreateString(attr) : 0;
  auto val__ = val ? _fbb.CreateString(val) : 0;
  return flat::CreateESMsg(
      _fbb,
      cmd,
      txid,
      type,
      attr__,
      val__);
}

struct Data FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_LABEL = 6,
    VT_ATTRIBUTE = 8,
    VT_VALUE = 10
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  const flatbuffers::String *attribute() const {
    return GetPointer<const flatbuffers::String *>(VT_ATTRIBUTE);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyOffset(verifier, VT_ATTRIBUTE) &&
           verifier.VerifyString(attribute()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct DataBuilder {
  typedef Data Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(Data::VT_KEY, key);
  }
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(Data::VT_LABEL, label);
  }
  void add_attribute(flatbuffers::Offset<flatbuffers::String> attribute) {
    fbb_.AddOffset(Data::VT_ATTRIBUTE, attribute);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(Data::VT_VALUE, value);
  }
  explicit DataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataBuilder &operator=(const DataBuilder &);
  flatbuffers::Offset<Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Data>(end);
    return o;
  }
};

inline flatbuffers::Offset<Data> CreateData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> label = 0,
    flatbuffers::Offset<flatbuffers::String> attribute = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  DataBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_attribute(attribute);
  builder_.add_label(label);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<Data> CreateDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *label = nullptr,
    const char *attribute = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto attribute__ = attribute ? _fbb.CreateString(attribute) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return flat::CreateData(
      _fbb,
      key__,
      label__,
      attribute__,
      value__);
}

struct DbServiceMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DbServiceMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD = 4,
    VT_TXID = 6,
    VT_NEEDGLOBALCONFLICT = 8,
    VT_ISCONFLICT = 10,
    VT_LSN = 12,
    VT_READSET = 14,
    VT_WRITESET = 16
  };
  int32_t cmd() const {
    return GetField<int32_t>(VT_CMD, 0);
  }
  int32_t txid() const {
    return GetField<int32_t>(VT_TXID, 0);
  }
  bool needGlobalConflict() const {
    return GetField<uint8_t>(VT_NEEDGLOBALCONFLICT, 0) != 0;
  }
  bool isConflict() const {
    return GetField<uint8_t>(VT_ISCONFLICT, 0) != 0;
  }
  int32_t lsn() const {
    return GetField<int32_t>(VT_LSN, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::Data>> *readSet() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::Data>> *>(VT_READSET);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::Data>> *writeSet() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::Data>> *>(VT_WRITESET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CMD) &&
           VerifyField<int32_t>(verifier, VT_TXID) &&
           VerifyField<uint8_t>(verifier, VT_NEEDGLOBALCONFLICT) &&
           VerifyField<uint8_t>(verifier, VT_ISCONFLICT) &&
           VerifyField<int32_t>(verifier, VT_LSN) &&
           VerifyOffset(verifier, VT_READSET) &&
           verifier.VerifyVector(readSet()) &&
           verifier.VerifyVectorOfTables(readSet()) &&
           VerifyOffset(verifier, VT_WRITESET) &&
           verifier.VerifyVector(writeSet()) &&
           verifier.VerifyVectorOfTables(writeSet()) &&
           verifier.EndTable();
  }
};

struct DbServiceMsgBuilder {
  typedef DbServiceMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cmd(int32_t cmd) {
    fbb_.AddElement<int32_t>(DbServiceMsg::VT_CMD, cmd, 0);
  }
  void add_txid(int32_t txid) {
    fbb_.AddElement<int32_t>(DbServiceMsg::VT_TXID, txid, 0);
  }
  void add_needGlobalConflict(bool needGlobalConflict) {
    fbb_.AddElement<uint8_t>(DbServiceMsg::VT_NEEDGLOBALCONFLICT, static_cast<uint8_t>(needGlobalConflict), 0);
  }
  void add_isConflict(bool isConflict) {
    fbb_.AddElement<uint8_t>(DbServiceMsg::VT_ISCONFLICT, static_cast<uint8_t>(isConflict), 0);
  }
  void add_lsn(int32_t lsn) {
    fbb_.AddElement<int32_t>(DbServiceMsg::VT_LSN, lsn, 0);
  }
  void add_readSet(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::Data>>> readSet) {
    fbb_.AddOffset(DbServiceMsg::VT_READSET, readSet);
  }
  void add_writeSet(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::Data>>> writeSet) {
    fbb_.AddOffset(DbServiceMsg::VT_WRITESET, writeSet);
  }
  explicit DbServiceMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DbServiceMsgBuilder &operator=(const DbServiceMsgBuilder &);
  flatbuffers::Offset<DbServiceMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DbServiceMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<DbServiceMsg> CreateDbServiceMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cmd = 0,
    int32_t txid = 0,
    bool needGlobalConflict = false,
    bool isConflict = false,
    int32_t lsn = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::Data>>> readSet = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::Data>>> writeSet = 0) {
  DbServiceMsgBuilder builder_(_fbb);
  builder_.add_writeSet(writeSet);
  builder_.add_readSet(readSet);
  builder_.add_lsn(lsn);
  builder_.add_txid(txid);
  builder_.add_cmd(cmd);
  builder_.add_isConflict(isConflict);
  builder_.add_needGlobalConflict(needGlobalConflict);
  return builder_.Finish();
}

inline flatbuffers::Offset<DbServiceMsg> CreateDbServiceMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cmd = 0,
    int32_t txid = 0,
    bool needGlobalConflict = false,
    bool isConflict = false,
    int32_t lsn = 0,
    const std::vector<flatbuffers::Offset<flat::Data>> *readSet = nullptr,
    const std::vector<flatbuffers::Offset<flat::Data>> *writeSet = nullptr) {
  auto readSet__ = readSet ? _fbb.CreateVector<flatbuffers::Offset<flat::Data>>(*readSet) : 0;
  auto writeSet__ = writeSet ? _fbb.CreateVector<flatbuffers::Offset<flat::Data>>(*writeSet) : 0;
  return flat::CreateDbServiceMsg(
      _fbb,
      cmd,
      txid,
      needGlobalConflict,
      isConflict,
      lsn,
      readSet__,
      writeSet__);
}

struct DbtlMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DbtlMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD = 4,
    VT_TXID = 6,
    VT_DATA = 8
  };
  int32_t cmd() const {
    return GetField<int32_t>(VT_CMD, 0);
  }
  int32_t txid() const {
    return GetField<int32_t>(VT_TXID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::Data>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::Data>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CMD) &&
           VerifyField<int32_t>(verifier, VT_TXID) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct DbtlMsgBuilder {
  typedef DbtlMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cmd(int32_t cmd) {
    fbb_.AddElement<int32_t>(DbtlMsg::VT_CMD, cmd, 0);
  }
  void add_txid(int32_t txid) {
    fbb_.AddElement<int32_t>(DbtlMsg::VT_TXID, txid, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::Data>>> data) {
    fbb_.AddOffset(DbtlMsg::VT_DATA, data);
  }
  explicit DbtlMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DbtlMsgBuilder &operator=(const DbtlMsgBuilder &);
  flatbuffers::Offset<DbtlMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DbtlMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<DbtlMsg> CreateDbtlMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cmd = 0,
    int32_t txid = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::Data>>> data = 0) {
  DbtlMsgBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_txid(txid);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

inline flatbuffers::Offset<DbtlMsg> CreateDbtlMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cmd = 0,
    int32_t txid = 0,
    const std::vector<flatbuffers::Offset<flat::Data>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<flat::Data>>(*data) : 0;
  return flat::CreateDbtlMsg(
      _fbb,
      cmd,
      txid,
      data__);
}

struct DbtlAckMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DbtlAckMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LSN = 4,
    VT_TXID = 6
  };
  int32_t lsn() const {
    return GetField<int32_t>(VT_LSN, 0);
  }
  int32_t txid() const {
    return GetField<int32_t>(VT_TXID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LSN) &&
           VerifyField<int32_t>(verifier, VT_TXID) &&
           verifier.EndTable();
  }
};

struct DbtlAckMsgBuilder {
  typedef DbtlAckMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lsn(int32_t lsn) {
    fbb_.AddElement<int32_t>(DbtlAckMsg::VT_LSN, lsn, 0);
  }
  void add_txid(int32_t txid) {
    fbb_.AddElement<int32_t>(DbtlAckMsg::VT_TXID, txid, 0);
  }
  explicit DbtlAckMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DbtlAckMsgBuilder &operator=(const DbtlAckMsgBuilder &);
  flatbuffers::Offset<DbtlAckMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DbtlAckMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<DbtlAckMsg> CreateDbtlAckMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t lsn = 0,
    int32_t txid = 0) {
  DbtlAckMsgBuilder builder_(_fbb);
  builder_.add_txid(txid);
  builder_.add_lsn(lsn);
  return builder_.Finish();
}

struct RootMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RootMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANY_TYPE = 4,
    VT_ANY = 6
  };
  flat::Msg any_type() const {
    return static_cast<flat::Msg>(GetField<uint8_t>(VT_ANY_TYPE, 0));
  }
  const void *any() const {
    return GetPointer<const void *>(VT_ANY);
  }
  template<typename T> const T *any_as() const;
  const flat::GtmMsg *any_as_GtmMsg() const {
    return any_type() == flat::Msg_GtmMsg ? static_cast<const flat::GtmMsg *>(any()) : nullptr;
  }
  const flat::AppMsg *any_as_AppMsg() const {
    return any_type() == flat::Msg_AppMsg ? static_cast<const flat::AppMsg *>(any()) : nullptr;
  }
  const flat::DbServiceMsg *any_as_DbServiceMsg() const {
    return any_type() == flat::Msg_DbServiceMsg ? static_cast<const flat::DbServiceMsg *>(any()) : nullptr;
  }
  const flat::DbtlMsg *any_as_DbtlMsg() const {
    return any_type() == flat::Msg_DbtlMsg ? static_cast<const flat::DbtlMsg *>(any()) : nullptr;
  }
  const flat::DbtlAckMsg *any_as_DbtlAckMsg() const {
    return any_type() == flat::Msg_DbtlAckMsg ? static_cast<const flat::DbtlAckMsg *>(any()) : nullptr;
  }
  const flat::ESMsg *any_as_ESMsg() const {
    return any_type() == flat::Msg_ESMsg ? static_cast<const flat::ESMsg *>(any()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ANY_TYPE) &&
           VerifyOffset(verifier, VT_ANY) &&
           VerifyMsg(verifier, any(), any_type()) &&
           verifier.EndTable();
  }
};

template<> inline const flat::GtmMsg *RootMsg::any_as<flat::GtmMsg>() const {
  return any_as_GtmMsg();
}

template<> inline const flat::AppMsg *RootMsg::any_as<flat::AppMsg>() const {
  return any_as_AppMsg();
}

template<> inline const flat::DbServiceMsg *RootMsg::any_as<flat::DbServiceMsg>() const {
  return any_as_DbServiceMsg();
}

template<> inline const flat::DbtlMsg *RootMsg::any_as<flat::DbtlMsg>() const {
  return any_as_DbtlMsg();
}

template<> inline const flat::DbtlAckMsg *RootMsg::any_as<flat::DbtlAckMsg>() const {
  return any_as_DbtlAckMsg();
}

template<> inline const flat::ESMsg *RootMsg::any_as<flat::ESMsg>() const {
  return any_as_ESMsg();
}

struct RootMsgBuilder {
  typedef RootMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_any_type(flat::Msg any_type) {
    fbb_.AddElement<uint8_t>(RootMsg::VT_ANY_TYPE, static_cast<uint8_t>(any_type), 0);
  }
  void add_any(flatbuffers::Offset<void> any) {
    fbb_.AddOffset(RootMsg::VT_ANY, any);
  }
  explicit RootMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RootMsgBuilder &operator=(const RootMsgBuilder &);
  flatbuffers::Offset<RootMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RootMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<RootMsg> CreateRootMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flat::Msg any_type = flat::Msg_NONE,
    flatbuffers::Offset<void> any = 0) {
  RootMsgBuilder builder_(_fbb);
  builder_.add_any(any);
  builder_.add_any_type(any_type);
  return builder_.Finish();
}

inline bool VerifyMsg(flatbuffers::Verifier &verifier, const void *obj, Msg type) {
  switch (type) {
    case Msg_NONE: {
      return true;
    }
    case Msg_GtmMsg: {
      auto ptr = reinterpret_cast<const flat::GtmMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Msg_AppMsg: {
      auto ptr = reinterpret_cast<const flat::AppMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Msg_DbServiceMsg: {
      auto ptr = reinterpret_cast<const flat::DbServiceMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Msg_DbtlMsg: {
      auto ptr = reinterpret_cast<const flat::DbtlMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Msg_DbtlAckMsg: {
      auto ptr = reinterpret_cast<const flat::DbtlAckMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Msg_ESMsg: {
      auto ptr = reinterpret_cast<const flat::ESMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMsgVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMsg(
        verifier,  values->Get(i), types->GetEnum<Msg>(i))) {
      return false;
    }
  }
  return true;
}

inline const flat::RootMsg *GetRootMsg(const void *buf) {
  return flatbuffers::GetRoot<flat::RootMsg>(buf);
}

inline const flat::RootMsg *GetSizePrefixedRootMsg(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<flat::RootMsg>(buf);
}

inline bool VerifyRootMsgBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flat::RootMsg>(nullptr);
}

inline bool VerifySizePrefixedRootMsgBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<flat::RootMsg>(nullptr);
}

inline void FinishRootMsgBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::RootMsg> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRootMsgBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::RootMsg> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flat

#endif  // FLATBUFFERS_GENERATED_NET_FLAT_H_
